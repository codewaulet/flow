<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FLOW v6 - Gesture UI</title>
    <!-- TailwindCSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js (Audio) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.min.js"></script>
    <!-- Three.js (WebGL) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body, html {
            margin: 0; padding: 0; overflow: hidden;
            background-color: #05050A; color: white;
            font-family: 'Inter', -apple-system, sans-serif;
            -webkit-tap-highlight-color: transparent;
            touch-action: none; /* Запрещаем скролл страницы жестами */
        }
        
        /* --- Контейнеры Режимов --- */
        .animation-view {
            width: 100%; height: 100%;
            position: fixed; top: 0; left: 0;
            opacity: 0; /* Скрыты по умолчанию */
            pointer-events: none; /* Неактивны по умолчанию */
            transition: opacity 0.5s ease-in-out;
            z-index: 1;
        }
        .animation-view.active {
            opacity: 1;
            pointer-events: auto; /* Активный режим получает события */
            z-index: 2; /* Активный режим поверх */
        }

        /* --- 1. Reflect (SVG Filter) --- */
        #reflect-view {
             background: #05050A; /* Фон для SVG режима */
             overflow: hidden; /* Обрезаем SVG */
        }
        #reflect-svg {
            width: 100%;
            height: 100%;
        }
        .reflect-blob {
            animation: reflect-move 30s infinite alternate ease-in-out;
        }
        @keyframes reflect-move {
            0% { transform: translate(10vw, 10vh) scale(1); }
            25% { transform: translate(70vw, 40vh) scale(1.2); }
            50% { transform: translate(40vw, 80vh) scale(0.8); }
            75% { transform: translate(10vw, 60vh) scale(1.1); }
            100% { transform: translate(10vw, 10vh) scale(1); }
        }

        /* --- 2. Breathe (CSS) --- */
        #breathe-view { display: flex; align-items: center; justify-content: center; }
        .breathe-container { position: relative; width: 300px; height: 300px; filter: blur(25px); animation: breathe-rotate 16s linear infinite; }
        .breathe-petal { position: absolute; width: 150px; height: 150px; border-radius: 50%; background: radial-gradient(circle, #a78bfa 0%, rgba(167, 139, 250, 0) 70%); left: 50%; top: 50%; margin-left: -75px; margin-top: -75px; transform-origin: center center; animation: breathe-scale 8s infinite ease-in-out; opacity: 0.7; }
        @keyframes breathe-rotate { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
        @keyframes breathe-scale { 0%, 100% { transform: scale(0.6); opacity: 0.5; } 50% { transform: scale(1); opacity: 1; } }

        /* --- 3-6 & NEW Zen (WebGL) --- */
        #webgl-canvas { width: 100%; height: 100%; position: fixed; top: 0; left: 0; z-index: 0; display: none; /* Скрыт по умолчанию */ }
        
        /* --- 7. Aura (CSS) --- */
        #aura-view { position: relative; }
        .aura-blob { position: absolute; border-radius: 50%; filter: blur(80px); opacity: 0.6; animation: aura-morph 20s infinite ease-in-out alternate; }
        @keyframes aura-morph { 0% { transform: scale(1) translate(0, 0) rotate(0deg); border-radius: 50% 60% 70% 40%; } 100% { transform: scale(1.5) translate(50px, -50px) rotate(180deg); border-radius: 70% 40% 50% 60%; } }
        
        /* --- 8. Matrix (2D Canvas) --- */
        #matrix-canvas { width: 100%; height: 100%; }

        /* --- НОВЫЙ UI: Индикаторы и Панель Настроек --- */
        #mode-indicator {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            z-index: 100;
            pointer-events: none; /* Чтобы не мешали кликам/тачам */
        }
        .indicator-dot {
            width: 8px;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            transition: background 0.3s ease;
        }
        .indicator-dot.active {
            background: rgba(255, 255, 255, 0.8);
        }

        #settings-overlay {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            max-height: 40vh; /* Макс высота панели */
            background: rgba(15, 15, 25, 0.8);
            backdrop-filter: blur(15px);
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 20px 20px 0 0;
            z-index: 99;
            transform: translateY(100%); /* Спрятано */
            transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            padding: 20px;
            box-sizing: border-box;
            color: #eee;
            overflow-y: auto;
        }
        #settings-overlay.open {
            transform: translateY(0);
        }
        #settings-overlay h3 { font-size: 1.1rem; font-weight: 600; margin-bottom: 16px; text-align: center; }
        .setting { margin-bottom: 16px; }
        .setting label { display: block; font-size: 0.75rem; color: #aaa; margin-bottom: 6px; }
        input[type="range"] { -webkit-appearance: none; width: 100%; height: 4px; background: rgba(255, 255, 255, 0.1); border-radius: 2px; outline: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; background: #a78bfa; border-radius: 50%; cursor: pointer; }
        input[type="range"]::-moz-range-thumb { width: 18px; height: 18px; background: #a78bfa; border-radius: 50%; cursor: pointer; }
        .setting button { width: 100%; padding: 8px; background: #a78bfa; color: white; border: none; border-radius: 8px; cursor: pointer; font-size: 0.9rem; }
    
    </style>
</head>
<body>
    
    <!-- === Контейнеры для всех режимов === -->
    <div id="reflect-view" class="animation-view active">
         <!-- НОВЫЙ Reflect на SVG -->
         <svg id="reflect-svg" width="100%" height="100%">
            <defs>
                <filter id="reflect-filter">
                    <feGaussianBlur stdDeviation="30" in="SourceGraphic" result="blur" />
                    <feColorMatrix in="blur" mode="matrix" 
                        values="1 0 0 0 0
                                0 1 0 0 0
                                0 0 1 0 0
                                0 0 0 18 -7" 
                        result="goo" />
                    <feComposite in="SourceGraphic" in2="goo" operator="atop"/>
                </filter>
            </defs>
            <!-- Глубокие фиолетово-синие цвета -->
            <g filter="url(#reflect-filter)">
                <circle cx="150" cy="150" r="80" fill="#4f46e5" class="reflect-blob" style="animation-delay: -1s; animation-duration: 32s;" />
                <circle cx="300" cy="400" r="120" fill="#7c3aed" class="reflect-blob" style="animation-delay: -3s; animation-duration: 30s;" />
                <circle cx="500" cy="200" r="100" fill="#4f46e5" class="reflect-blob" style="animation-delay: -5s; animation-duration: 35s;" />
                <circle cx="400" cy="300" r="90" fill="#6d28d9" class="reflect-blob" style="animation-delay: -7s; animation-duration: 28s;" />
            </g>
        </svg>
    </div>
    <div id="breathe-view" class="animation-view">
        <div class="breathe-container">
            <div class="breathe-petal" style="transform: rotate(0deg) translateX(40px) scale(0.6); animation-delay: -1s;"></div>
            <div class="breathe-petal" style="transform: rotate(60deg) translateX(40px) scale(0.6); animation-delay: -2s;"></div>
            <div class="breathe-petal" style="transform: rotate(120deg) translateX(40px) scale(0.6); animation-delay: -3s;"></div>
            <div class="breathe-petal" style="transform: rotate(180deg) translateX(40px) scale(0.6); animation-delay: -4s;"></div>
            <div class="breathe-petal" style="transform: rotate(240deg) translateX(40px) scale(0.6); animation-delay: -5s;"></div>
            <div class="breathe-petal" style="transform: rotate(300deg) translateX(40px) scale(0.6); animation-delay: -6s;"></div>
        </div>
    </div>
    <div id="toroid-view" class="animation-view"></div>
    <div id="zen-view" class="animation-view"></div>
    <div id="cymatics-view" class="animation-view"></div>
    <div id="weaver-view" class="animation-view"></div>
    <div id="starfield-view" class="animation-view"></div>
    <div id="orbs-view" class="animation-view"></div>
    <div id="aura-view" class="animation-view">
        <div class="aura-blob" style="width: 500px; height: 500px; top: 10%; left: 10%; background: #a78bfa; animation-duration: 20s;"></div>
        <div class="aura-blob" style="width: 400px; height: 400px; top: 30%; left: 40%; background: #7c3aed; animation-duration: 15s; animation-delay: -5s;"></div>
        <div class="aura-blob" style="width: 300px; height: 300px; top: 50%; left: 20%; background: #6d28d9; animation-duration: 25s; animation-delay: -10s;"></div>
    </div>
    <div id="matrix-view" class="animation-view">
        <canvas id="matrix-canvas"></canvas>
    </div>
    
    <!-- Единый холст для всех WebGL-приложений -->
    <canvas id="webgl-canvas"></canvas>

    <!-- === UI === -->
    <div id="mode-indicator"></div>
    <div id="settings-overlay">
        <h3 id="settings-title">Настройки</h3>
        <div id="settings-content"></div>
    </div>
    
    <!-- 
    =====================================================================
    ШЕЙДЕРЫ (GLSL)
    =====================================================================
    -->
    
    <!-- Reflect УДАЛЕН -->
    
    <!-- Cymatics 2.0 (Shaders) - без изменений -->
    <script id="cymatics-fs" type="x-shader/x-fragment">uniform float u_time; uniform vec3 u_color; uniform float u_frequencies[5]; uniform float u_amplitudes[5]; varying vec2 vUv; void main() { float total_wave = 0.0; float total_amplitude = 0.0; for(int i=0; i < 5; i++) { if (u_amplitudes[i] > 0.0) { float freq = u_frequencies[i] * 0.01; float amp = u_amplitudes[i]; total_wave += sin(vUv.x * freq * 10.0 + u_time) * cos(vUv.y * freq * 10.0 + u_time) * amp; total_amplitude += amp; } } if (total_amplitude > 0.0) { total_wave /= total_amplitude; } float value = smoothstep(-0.5, 0.5, total_wave); gl_FragColor = vec4(u_color * value, 1.0); }</script>
    <script id="cymatics-vs" type="x-shader/x-vertex">varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }</script>
    
    <!-- НОВЫЙ Zen (Water Ripple Vertex Shader) -->
    <script id="zen-vs" type="x-shader/x-vertex">
        uniform float u_time;
        uniform vec2 u_mouse_pos; // Позиция клика/тача (0.0 to 1.0)
        uniform float u_ripple_intensity; // Сила волны (затухает со временем)
        uniform float u_frequency;
        uniform float u_amplitude;
        
        varying float v_displacement;

        void main() {
            vec2 pos_2d = position.xy; // Используем XY для плоскости
            vec2 uv = position.xy * 0.5 + 0.5; // UV от 0 до 1

            // Расстояние от точки клика до вершины
            float dist = distance(uv, u_mouse_pos);
            
            // Затухающая синусоида волны
            float wave = u_ripple_intensity * exp(-dist * 5.0) * // Затухание от центра
                         sin(dist * u_frequency - u_time * 5.0); // Волна расходится
            
            vec3 displaced_pos = position + normal * wave * u_amplitude;
            v_displacement = wave; // Передаем смещение во фрагментный шейдер

            gl_Position = projectionMatrix * modelViewMatrix * vec4(displaced_pos, 1.0);
        }
    </script>
     <!-- НОВЫЙ Zen (Water Ripple Fragment Shader) -->
    <script id="zen-fs" type="x-shader/x-fragment">
        uniform vec3 u_color_deep;
        uniform vec3 u_color_shallow;
        varying float v_displacement; // Получаем смещение из вершинного

        void main() {
            // Используем смещение для окрашивания (глубина/высота волны)
            float mix_factor = smoothstep(-0.5, 0.5, v_displacement); // От -1 до 1 -> 0 до 1
            vec3 color = mix(u_color_deep, u_color_shallow, mix_factor);
            
            // Добавляем небольшой блик на гребне волны
            float specular = pow(max(0.0, v_displacement), 2.0) * 0.5;
            color += vec3(specular);

            gl_FragColor = vec4(color, 1.0);
        }
    </script>
    
    <!-- 
    =====================================================================
    ОСНОВНОЙ JAVASCRIPT
    =====================================================================
    -->
    <script type="module"> // Используем module для лучшей организации
        // --- Импорты (если бы они были) ---
        // import * as THREE from 'three'; // <- Загружается глобально через CDN
        // import * as Tone from 'tone'; // <- Загружается глобально через CDN

        // --- Глобальные переменные ---
        let activeMode = null;
        let activeModeName = 'reflect';
        let currentModeIndex = 0; // Для свайпов
        const modeOrder = ['reflect', 'breathe', 'toroid', 'zen', 'cymatics', 'weaver', 'starfield', 'orbs', 'aura', 'matrix'];
        
        let audioState = { isReady: false, polySynth: null, analyser: null };
        let raycaster, mouse = new THREE.Vector2();
        let lastMousePos = { x: 0, y: 0, vel: 0.0, lastTime: 0 }; // Для расчета скорости
        
        const settingsOverlay = document.getElementById('settings-overlay');
        const settingsTitle = document.getElementById('settings-title');
        const settingsContent = document.getElementById('settings-content');
        const modeIndicator = document.getElementById('mode-indicator');
        const webglCanvas = document.getElementById('webgl-canvas'); // Единый холст
        let webglRenderer, webglScene, webglClock, globalRAFID; // Глобальные для WebGL

        const modeInstances = {};

        // --- Настройки по умолчанию ---
        const settings = {
            reflect: { speed: 30, blur: 30, color: '#4f46e5' }, // Используем SVG
            breathe: { speed: 8.0, blur: 25 },
            toroid: { speed: 0.5, radius: 15.0, count: 5000, size: 0.1 },
            zen: { frequency: 30.0, amplitude: 0.3, rippleDecay: 0.95 }, // Настройки для волн
            cymatics: { scale: 'Pentatonic', baseNote: 'C3' },
            weaver: { gravity: 1.0, damping: 0.95, count: 3000, size: 0.1 },
            starfield: { speed: 1.0, count: 5000, size: 0.1 },
            orbs: { speed: 0.5, count: 200, size: 0.2 },
            aura: { speed: 20.0, blur: 80.0 },
            matrix: { speed: 1.0, fontSize: 16 }
        };
        
        // --- Аудио Контекст ---
        async function initAudio() { 
            if (audioState.isReady) return;
            // Проверяем, загружен ли Tone.js
            if (typeof window.Tone === 'undefined') { 
                console.error("Tone.js не загружен. Попытка инициализации аудио отложена."); 
                // Можно попробовать загрузить еще раз или показать сообщение
                return; 
            }
            try {
                // await Tone.start(); // Tone уже должен быть доступен
                // Tone.start() должен быть вызван пользовательским жестом, делаем это в onInteractionStart
                const reverb = new window.Tone.Reverb({ decay: 10, wet: 0.5 }).toDestination();
                await reverb.generate();
                const polySynth = new window.Tone.PolySynth(window.Tone.Synth, {
                    oscillator: { type: 'sine' },
                    envelope: { attack: 0.5, decay: 0.1, sustain: 0.8, release: 1.0 }
                }).connect(reverb);
                const analyser = new window.Tone.Analyser('fft', 32);
                polySynth.connect(analyser);
                audioState = { isReady: true, polySynth, analyser };
                console.log("Audio Engine Ready.");
            } catch (e) { 
                console.error("Audio failed to initialize:", e); 
            }
        }
        
        // --- Менеджер Режимов ---
        function switchMode(index, direction = 0) { 
            if (index < 0 || index >= modeOrder.length) return; 
            if (activeModeName === modeOrder[index] && modeInstances[activeModeName]) return; // Проверяем, что режим уже инициализирован

            const newModeName = modeOrder[index];
            
            // 1. Анимация перехода (простой fade)
            if (activeModeName) {
                const oldView = document.getElementById(`${activeModeName}-view`);
                if (oldView) oldView.classList.remove('active');
            }
            
            // 2. Остановить старый режим
            if (activeMode && activeMode.stop) activeMode.stop();
            webglScene.clear(); // Всегда очищаем WebGL сцену
            
            // 3. Активировать новый режим (View)
            activeModeName = newModeName;
            currentModeIndex = index;
            const view = document.getElementById(`${activeModeName}-view`);
            if (view) view.classList.add('active');
            else { console.error(`View ${newModeName}-view не найден!`); return; }
            
            // 4. Инициализировать (если нужно) и запустить логику
            if (!modeInstances[activeModeName]) {
                const initFunction = modeInitializers[activeModeName];
                if (initFunction) {
                    modeInstances[activeModeName] = initFunction(view);
                } else {
                    console.error(`Нет инициализатора для ${newModeName}`);
                    return;
                }
            }
            
            activeMode = modeInstances[activeModeName];
            if (activeMode && activeMode.start) {
                activeMode.start();
            }
            
            // 5. Обновить индикаторы
            updateModeIndicator();
            
            // 6. Закрыть настройки, если были открыты
            settingsOverlay.classList.remove('open');
            isSettingsOpen = false; 
            
            // 7. Показать/Скрыть WebGL холст
            const isWebGLMode = ['toroid', 'zen', 'cymatics', 'weaver', 'starfield', 'orbs'].includes(newModeName);
            webglCanvas.style.display = isWebGLMode ? 'block' : 'none';
        }

        // --- Инициализаторы для каждого режима ---
        const modeInitializers = {
            'reflect': (view) => {
                 const svg = view.querySelector('svg');
                 function resize() {}
                 function populate(container) { /* ... (без изменений) ... */ 
                     const s = settings.reflect;
                     container.innerHTML = `
                        <div class="setting"><label>Скорость анимации (${s.speed.toFixed(0)})</label><input type="range" data-setting="speed" min="10" max="60" step="1" value="${s.speed}"></div>
                        <div class="setting"><label>Размытие (${s.blur.toFixed(0)})</label><input type="range" data-setting="blur" min="10" max="50" step="1" value="${s.blur}"></div>
                    `;
                    container.querySelector('[data-setting="speed"]').addEventListener('input', e => {
                        s.speed = parseFloat(e.target.value);
                        view.querySelectorAll('.reflect-blob').forEach(blob => blob.style.animationDuration = `${s.speed}s`);
                        e.target.previousElementSibling.textContent = `Скорость анимации (${s.speed.toFixed(0)})`;
                    });
                     container.querySelector('[data-setting="blur"]').addEventListener('input', e => {
                        s.blur = parseFloat(e.target.value);
                        svg.querySelector('feGaussianBlur').setAttribute('stdDeviation', s.blur);
                        e.target.previousElementSibling.textContent = `Размытие (${s.blur.toFixed(0)})`;
                    });
                 }
                return { settings: settings.reflect, start: () => {}, stop: () => {}, resize, populateSettings: populate };
            },
            'breathe': (view) => {
                 function populate(container) { /* ... (без изменений) ... */ 
                     const s = settings.breathe;
                     container.innerHTML = `
                         <div class="setting"><label>Скорость дыхания (${s.speed.toFixed(1)} сек/цикл)</label><input type="range" data-setting="speed" min="4" max="12" step="0.5" value="${s.speed}"></div>
                        <div class="setting"><label>Размытие (${s.blur.toFixed(0)})</label><input type="range" data-setting="blur" min="10" max="50" step="1" value="${s.blur}"></div>
                     `;
                      container.querySelector('[data-setting="speed"]').addEventListener('input', e => {
                        s.speed = parseFloat(e.target.value);
                        view.querySelectorAll('.breathe-petal').forEach(p => p.style.animationDuration = `${s.speed}s`);
                         e.target.previousElementSibling.textContent = `Скорость дыхания (${s.speed.toFixed(1)} сек/цикл)`;
                     });
                     container.querySelector('[data-setting="blur"]').addEventListener('input', e => {
                        s.blur = parseFloat(e.target.value);
                        view.querySelector('.breathe-container').style.filter = `blur(${s.blur}px)`;
                        e.target.previousElementSibling.textContent = `Размытие (${s.blur.toFixed(0)})`;
                     });
                 }
                return { settings: settings.breathe, start: ()=>{}, stop: ()=>{}, populateSettings: populate };
            },
            'toroid': (view) => {
                let particles, camera, s = settings.toroid;
                let isDragging = false, previousMousePos = { x: 0, y: 0 };
                function init() {
                    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                    camera.position.z = 30;
                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array(s.count * 3);
                    const data = []; const R = s.radius, r = 5.0;
                    for (let i = 0; i < s.count; i++) {
                        const u = Math.random() * Math.PI * 2, v = Math.random() * Math.PI * 2;
                        data.push({ u, v, speed: 0.1 + Math.random() * 0.4 });
                        positions[i * 3] = (R + r * Math.cos(v)) * Math.cos(u);
                        positions[i * 3 + 1] = (R + r * Math.cos(v)) * Math.sin(u);
                        positions[i * 3 + 2] = r * Math.sin(v);
                    }
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    geometry.userData = { data, R, r };
                    const material = new THREE.PointsMaterial({ color: '#a78bfa', size: s.size });
                    particles = new THREE.Points(geometry, material);
                    webglScene.add(particles);
                }
                 function start() { init(); }
                 function stop() { webglScene.clear(); particles = null; camera = null; } // Очистка объектов
                 function update() {
                    if (!particles) return; // Проверка
                    const data = particles.geometry.userData.data;
                    const positions = particles.geometry.attributes.position.array;
                    const speed = s.speed * 0.1;
                    const R = s.radius, r = particles.geometry.userData.r;
                    for(let i=0; i < data.length; i++) {
                        data[i].u += data[i].speed * speed; data[i].v += 0.01 * speed;
                        const u = data[i].u, v = data[i].v;
                        positions[i * 3] = (R + r * Math.cos(v)) * Math.cos(u);
                        positions[i * 3 + 1] = (R + r * Math.cos(v)) * Math.sin(u);
                        positions[i * 3 + 2] = r * Math.sin(v);
                    }
                    particles.geometry.attributes.position.needsUpdate = true;
                    webglRenderer.render(webglScene, camera); 
                 }
                 function resize(w, h) { if(camera) { camera.aspect = w / h; camera.updateProjectionMatrix(); } }
                 function handleInteraction(event) {
                    if (!particles) return; // Проверка
                    if (event.type === 'mousedown' || event.type === 'touchstart') {
                        isDragging = true;
                        previousMousePos.x = event.clientX || event.touches[0].clientX;
                        previousMousePos.y = event.clientY || event.touches[0].clientY;
                    }
                    if (event.type === 'mouseup' || event.type === 'touchend') isDragging = false;
                    if ((event.type === 'mousemove' || event.type === 'touchmove') && isDragging) {
                        const clientX = event.clientX || event.touches[0].clientX;
                        const clientY = event.clientY || event.touches[0].clientY;
                        const deltaX = clientX - previousMousePos.x, deltaY = clientY - previousMousePos.y;
                        particles.rotateOnWorldAxis(new THREE.Vector3(1, 0, 0), deltaY * 0.01);
                        particles.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), deltaX * 0.01);
                        previousMousePos.x = clientX; previousMousePos.y = clientY;
                    }
                 }
                 function populate(container) { /* ... настройки toroid ... */ }
                return { settings: s, start, stop, update, resize, handleInteraction, populateSettings: populate };
            },
            'zen': (view) => {
                let waterPlane, camera, s = settings.zen;
                let rippleUniforms = {
                    u_time: { value: 0.0 }, u_mouse_pos: { value: new THREE.Vector2(0.5, 0.5) },
                    u_ripple_intensity: { value: 0.0 }, u_frequency: { value: s.frequency },
                    u_amplitude: { value: s.amplitude }, u_color_deep: { value: new THREE.Color(0x0a0a1a) },
                    u_color_shallow: { value: new THREE.Color(0x2a2a5a) }
                };
                function init() {
                    camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                    camera.position.set(0, 5, 10); camera.lookAt(0, 0, 0);
                    const geometry = new THREE.PlaneGeometry(20, 20, 100, 100);
                    const material = new THREE.ShaderMaterial({
                        vertexShader: document.getElementById('zen-vs').textContent,
                        fragmentShader: document.getElementById('zen-fs').textContent,
                        uniforms: rippleUniforms
                    });
                    waterPlane = new THREE.Mesh(geometry, material);
                    waterPlane.rotation.x = -Math.PI / 2;
                    webglScene.add(waterPlane);
                    const ambient = new THREE.AmbientLight(0xffffff, 1.0); webglScene.add(ambient);
                }
                function start() { init(); }
                function stop() { webglScene.clear(); waterPlane = null; camera = null; }
                function update(time) {
                    if (!waterPlane) return;
                    rippleUniforms.u_time.value = time;
                    rippleUniforms.u_ripple_intensity.value *= s.rippleDecay;
                    webglRenderer.render(webglScene, camera);
                }
                function resize(w, h) { if(camera) { camera.aspect = w / h; camera.updateProjectionMatrix(); } }
                function handleInteraction(e) {
                     if (e.type === 'mousedown' || e.type === 'touchstart') {
                        const clientX = e.clientX || e.touches[0].clientX;
                        const clientY = e.clientY || e.touches[0].clientY;
                        mouse.x = clientX / window.innerWidth;
                        mouse.y = 1.0 - (clientY / window.innerHeight);
                        rippleUniforms.u_mouse_pos.value.copy(mouse);
                        rippleUniforms.u_ripple_intensity.value = 1.0;
                     }
                 }
                function populate(container) { /* ... настройки zen ... */ 
                     container.innerHTML = `
                        <div class="setting"><label>Частота волн (${s.frequency.toFixed(0)})</label><input type="range" data-setting="frequency" min="10" max="100" step="1" value="${s.frequency}"></div>
                        <div class="setting"><label>Амплитуда (${s.amplitude.toFixed(1)})</label><input type="range" data-setting="amplitude" min="0.1" max="1.0" step="0.1" value="${s.amplitude}"></div>
                        <div class="setting"><label>Затухание (${s.rippleDecay.toFixed(2)})</label><input type="range" data-setting="rippleDecay" min="0.90" max="0.99" step="0.01" value="${s.rippleDecay}"></div>
                    `;
                    container.querySelector('[data-setting="frequency"]').addEventListener('input', e => {
                        s.frequency = parseFloat(e.target.value);
                        rippleUniforms.u_frequency.value = s.frequency;
                        e.target.previousElementSibling.textContent = `Частота волн (${s.frequency.toFixed(0)})`;
                    });
                     container.querySelector('[data-setting="amplitude"]').addEventListener('input', e => {
                        s.amplitude = parseFloat(e.target.value);
                        rippleUniforms.u_amplitude.value = s.amplitude;
                        e.target.previousElementSibling.textContent = `Амплитуда (${s.amplitude.toFixed(1)})`;
                    });
                    container.querySelector('[data-setting="rippleDecay"]').addEventListener('input', e => {
                        s.rippleDecay = parseFloat(e.target.value);
                         e.target.previousElementSibling.textContent = `Затухание (${s.rippleDecay.toFixed(2)})`;
                    });
                }
                return { settings: s, start, stop, update, resize, handleInteraction, populateSettings: populate };
            },
            'cymatics': (view) => {
                let material, camera, s = settings.cymatics;
                let activeNotes = {};
                const scale = ['C3', 'D3', 'E3', 'G3', 'A3', 'C4', 'D4', 'E4', 'G4', 'A4'];
                function init() {
                    camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
                    const geometry = new THREE.PlaneGeometry(2, 2);
                    material = new THREE.ShaderMaterial({
                        vertexShader: document.getElementById('cymatics-vs').textContent,
                        fragmentShader: document.getElementById('cymatics-fs').textContent,
                        uniforms: {
                            u_time: { value: 0.0 }, u_color: { value: new THREE.Color('#a78bfa') },
                            u_frequencies: { value: [0.0, 0.0, 0.0, 0.0, 0.0] },
                            u_amplitudes: { value: [0.0, 0.0, 0.0, 0.0, 0.0] }
                        }
                    });
                    const quad = new THREE.Mesh(geometry, material);
                    quad.frustumCulled = false;
                    webglScene.add(quad);
                }
                 function start() { init(); }
                 function stop() { webglScene.clear(); if(audioState.isReady && audioState.polySynth) audioState.polySynth.releaseAll(); activeNotes = {}; material = null; camera = null; }
                 function update(time) {
                    if (!material) return; // Проверка
                    material.uniforms.u_time.value = time;
                    if (audioState.isReady && audioState.analyser) {
                        const fft = audioState.analyser.getValue();
                        const amps = [0.0, 0.0, 0.0, 0.0, 0.0], freqs = [0.0, 0.0, 0.0, 0.0, 0.0];
                        let notes = Object.keys(activeNotes);
                        for(let i=0; i < 5; i++) {
                            if (i < fft.length && i < notes.length && window.Tone && window.Tone.Frequency) { // Доп. проверка
                                amps[i] = Math.max(0, (fft[i] + 100) / 100); 
                                freqs[i] = window.Tone.Frequency(notes[i]).toFrequency();
                            }
                        }
                        material.uniforms.u_amplitudes.value = amps;
                        material.uniforms.u_frequencies.value = freqs;
                    }
                    webglRenderer.render(webglScene, camera);
                 }
                 function handleInteraction(e) {
                    if (!audioState.isReady) initAudio(); // Инициализируем аудио здесь, если еще не готово
                    if (!audioState.isReady || !audioState.polySynth) return; // Выход, если аудио не готово

                    const clientX = e.clientX || e.touches[0].clientX;
                    const noteIndex = Math.floor((clientX / window.innerWidth) * scale.length);
                    const note = scale[noteIndex];
                    if (e.type === 'mousedown' || e.type === 'touchstart') {
                        if (note && !activeNotes[note]) {
                            audioState.polySynth.triggerAttack(note); activeNotes[note] = true;
                        }
                    } else if (e.type === 'mouseup' || e.type === 'touchend') {
                         audioState.polySynth.releaseAll(); activeNotes = {};
                    }
                 }
                return { settings: s, start, stop, update, handleInteraction };
            },
            'weaver': (view) => {
                let particles, camera, s = settings.weaver;
                let gravityWell = new THREE.Vector3(0, 0, 0);
                let isAttracting = false;
                function init() { /* ... */ 
                    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                    camera.position.z = 50;
                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array(s.count * 3), velocities = new Float32Array(s.count * 3);
                    for (let i = 0; i < s.count; i++) {
                        positions[i * 3] = (Math.random() - 0.5) * 100; positions[i * 3 + 1] = (Math.random() - 0.5) * 100; positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
                        velocities[i * 3] = 0; velocities[i * 3 + 1] = 0; velocities[i * 3 + 2] = 0;
                    }
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    geometry.userData.velocities = velocities;
                    const material = new THREE.PointsMaterial({ color: '#a78bfa', size: s.size, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.7 });
                    particles = new THREE.Points(geometry, material);
                    webglScene.add(particles);
                }
                function start() { init(); }
                function stop() { webglScene.clear(); particles = null; camera = null; }
                function update() { /* ... */ 
                    if (!particles) return;
                    const positions = particles.geometry.attributes.position.array;
                    const velocities = particles.geometry.userData.velocities;
                    const gravity = s.gravity * 0.1, damping = s.damping;
                    for (let i = 0; i < positions.length; i += 3) {
                        if (isAttracting) {
                            const dx = gravityWell.x - positions[i], dy = gravityWell.y - positions[i + 1], dz = gravityWell.z - positions[i + 2];
                            const distSq = dx * dx + dy * dy + dz * dz;
                            if (distSq > 1.0) { const force = gravity / (distSq + 1.0); velocities[i] += dx * force; velocities[i + 1] += dy * force; velocities[i + 2] += dz * force; }
                        }
                        velocities[i] *= damping; velocities[i + 1] *= damping; velocities[i + 2] *= damping;
                        positions[i] += velocities[i]; positions[i + 1] += velocities[i + 1]; positions[i + 2] += velocities[i + 2];
                    }
                    particles.geometry.attributes.position.needsUpdate = true;
                    webglRenderer.render(webglScene, camera);
                }
                function resize(w, h) { if(camera) { camera.aspect = w / h; camera.updateProjectionMatrix(); } }
                function handleInteraction(e) { /* ... */ 
                    if (!camera) return; // Добавлена проверка
                    const clientX = e.clientX || e.touches[0].clientX;
                    const clientY = e.clientY || e.touches[0].clientY;
                    mouse.x = (clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(clientY / window.innerHeight) * 2 + 1;
                    raycaster.setFromCamera(mouse, camera);
                    const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
                    raycaster.ray.intersectPlane(plane, gravityWell);
                    if (e.type === 'mousedown' || e.type === 'touchstart') isAttracting = true;
                    if (e.type === 'mouseup' || e.type === 'touchend') isAttracting = false;
                }
                return { settings: s, start, stop, update, resize, handleInteraction };
            },
            'starfield': (view) => {
                let particles, camera, s = settings.starfield;
                function init() { /* ... */ 
                    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                    camera.position.z = 10;
                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array(s.count * 3);
                    for (let i = 0; i < s.count; i++) { positions[i * 3] = (Math.random() - 0.5) * 100; positions[i * 3 + 1] = (Math.random() - 0.5) * 100; positions[i * 3 + 2] = (Math.random() - 0.5) * 100; }
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    const material = new THREE.PointsMaterial({ color: '#ffffff', size: s.size });
                    particles = new THREE.Points(geometry, material);
                    webglScene.add(particles);
                }
                function start() { init(); }
                function stop() { webglScene.clear(); particles = null; camera = null; }
                function update() { /* ... */ 
                     if (!particles) return;
                    const positions = particles.geometry.attributes.position.array;
                    for (let i = 0; i < positions.length; i += 3) { positions[i + 2] += s.speed * 0.1; if (positions[i + 2] > 50) positions[i + 2] = -50; }
                    particles.geometry.attributes.position.needsUpdate = true;
                    webglRenderer.render(webglScene, camera);
                }
                function resize(w, h) { if(camera) { camera.aspect = w / h; camera.updateProjectionMatrix(); } }
                return { settings: s, start, stop, update, resize };
            },
             'orbs': (view) => {
                let particles, camera, s = settings.orbs;
                function init() { /* ... */ 
                    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                    camera.position.z = 30;
                    const geometry = new THREE.BufferGeometry();
                    const positions = new Float32Array(s.count * 3), data = [];
                    for (let i = 0; i < s.count; i++) {
                        positions[i * 3] = 0; positions[i * 3 + 1] = 0; positions[i * 3 + 2] = 0;
                        data.push({ phaseX: Math.random() * Math.PI * 2, phaseY: Math.random() * Math.PI * 2, phaseZ: Math.random() * Math.PI * 2, speedX: (Math.random() - 0.5) * 0.5, speedY: (Math.random() - 0.5) * 0.5, speedZ: (Math.random() - 0.5) * 0.5, radius: 5 + Math.random() * 15 });
                    }
                    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                    geometry.userData.data = data;
                    const material = new THREE.PointsMaterial({ color: '#a78bfa', size: s.size });
                    particles = new THREE.Points(geometry, material);
                    webglScene.add(particles);
                }
                function start() { init(); }
                function stop() { webglScene.clear(); particles = null; camera = null; }
                function update() { /* ... */ 
                    if (!particles) return;
                    const data = particles.geometry.userData.data, positions = particles.geometry.attributes.position.array;
                    for(let i = 0; i < data.length; i++) {
                        const d = data[i];
                        d.phaseX += d.speedX * s.speed * 0.1; d.phaseY += d.speedY * s.speed * 0.1; d.phaseZ += d.speedZ * s.speed * 0.1;
                        positions[i * 3] = Math.sin(d.phaseX) * d.radius; positions[i * 3 + 1] = Math.cos(d.phaseY) * d.radius; positions[i * 3 + 2] = Math.sin(d.phaseZ) * Math.cos(d.phaseX) * d.radius;
                    }
                    particles.geometry.attributes.position.needsUpdate = true;
                    webglRenderer.render(webglScene, camera);
                }
                function resize(w, h) { if(camera) { camera.aspect = w / h; camera.updateProjectionMatrix(); } }
                 return { settings: s, start, stop, update, resize };
            },
            'aura': (view) => {
                // CSS
                return { settings: settings.aura, start: ()=>{}, stop: ()=>{} };
            },
            'matrix': (view) => {
                const canvas = view.querySelector('canvas');
                const ctx = canvas.getContext('2d');
                let s = settings.matrix;
                let cols, drops, rafId;
                function init() {
                    canvas.width = window.innerWidth; canvas.height = window.innerHeight;
                    cols = Math.floor(canvas.width / s.fontSize);
                    drops = [];
                    for (let i = 0; i < cols; i++) drops[i] = Math.floor(Math.random() * canvas.height);
                }
                function draw() {
                    rafId = requestAnimationFrame(draw);
                    ctx.fillStyle = 'rgba(5, 5, 10, 0.05)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.fillStyle = '#a78bfa'; ctx.font = `${s.fontSize}px monospace`;
                    for (let i = 0; i < drops.length; i++) {
                        const text = String.fromCharCode(0x30A0 + Math.random() * 96);
                        ctx.fillText(text, i * s.fontSize, drops[i] * s.fontSize);
                        if (drops[i] * s.fontSize > canvas.height && Math.random() > 0.975) drops[i] = 0;
                        drops[i] += s.speed;
                    }
                }
                function resize() { init(); }
                return { settings: s, start: ()=>{init(); draw();}, stop: ()=>cancelAnimationFrame(rafId), resize };
            }
        };

        // --- Заполнение Панели Настроек ---
        function populateSettings(modeName) {
            const mode = modeInstances[modeName];
            settingsTitle.textContent = `Настройки: ${modeName}`;
            settingsContent.innerHTML = ''; // Очищаем перед заполнением
            if (!mode || !mode.settings) {
                settingsContent.innerHTML = '<p class="text-gray-400 text-sm">Настройки недоступны</p>';
                return;
            };
            // Передаем контейнер в метод режима
            if (mode.populateSettings) {
                mode.populateSettings(settingsContent);
            } else {
                 // Генерация настроек по умолчанию
                const s = mode.settings;
                let html = '';
                for (const key in s) {
                    if (typeof s[key] === 'number') {
                        let min = 0.1, max = 10.0, step = 0.1;
                        if (key === 'count') { min = 100; max = 10000; step = 100; }
                        else if (key === 'size') { max = 1.0; }
                        else if (key === 'radius') { max = 50.0; }
                        else if (key === 'blur' || key === 'fontSize') { min = 5; max = 100; step = 1; }
                        else if (key === 'damping' || key === 'rippleDecay') { min = 0.9; max = 0.99; step = 0.01; } // Исправлено

                         html += `<div class="setting"><label>${key} (${s[key].toFixed(key.includes('Decay') || key.includes('damping') ? 2 : (key === 'count' || key === 'fontSize' || key === 'blur' ? 0: 1))})</label><input type="range" data-setting="${key}" min="${min}" max="${max}" step="${step}" value="${s[key]}"></div>`; // Исправлен toFixed
                    }
                }
                 settingsContent.innerHTML = html || '<p class="text-gray-400 text-sm">Настройки недоступны</p>';
            }
        }

        // --- Обновление Индикаторов Режима ---
        function updateModeIndicator() {
            modeIndicator.innerHTML = '';
            modeOrder.forEach((mode, index) => {
                const dot = document.createElement('div');
                dot.className = 'indicator-dot';
                if (index === currentModeIndex) {
                    dot.classList.add('active');
                }
                modeIndicator.appendChild(dot);
            });
        }
        
        // --- Глобальные Слушатели Жестов и Мыши ---
        let touchStartX = 0, touchStartY = 0, isSwiping = false, isSettingsOpen = false;

        // Определяем функции ДО их использования
        function onInteractionStart(e) {
            // Запускаем аудио контекст по первому взаимодействию
            if (!audioState.isReady && window.Tone && typeof window.Tone.start === 'function') {
                window.Tone.start().then(() => {
                    console.log("AudioContext started by user gesture.");
                    initAudio(); // Теперь инициализируем остальное
                }).catch(err => {
                    console.error("Failed to start AudioContext:", err);
                });
            } else if (audioState.isReady) {
                 // Если уже готово, просто передаем событие
                 if (activeMode && activeMode.handleInteraction) activeMode.handleInteraction(e);
            }

            const x = e.clientX || (e.touches ? e.touches[0].clientX : 0);
            const y = e.clientY || (e.touches ? e.touches[0].clientY : 0);
            lastMousePos.x = x;
            lastMousePos.y = y;
            lastMousePos.lastTime = performance.now();
            lastMousePos.vel = 0;
            // Передаем событие активному режиму ТОЛЬКО если аудио уже готово (или не нужно)
            if (activeMode && activeMode.handleInteraction && audioState.isReady) {
                activeMode.handleInteraction(e);
            }
        }

        function onInteractionMove(e) {
            const time = performance.now();
            const deltaTime = Math.max(1, time - lastMousePos.lastTime); 
            const x = e.clientX || (e.touches ? e.touches[0].clientX : 0);
            const y = e.clientY || (e.touches ? e.touches[0].clientY : 0);
            const dx = x - lastMousePos.x;
            const dy = y - lastMousePos.y;
            const currentVel = Math.sqrt(dx * dx + dy * dy) / deltaTime;
            lastMousePos.vel = THREE.MathUtils.lerp(lastMousePos.vel, currentVel, 0.2); 
            lastMousePos.x = x;
            lastMousePos.y = y;
            lastMousePos.lastTime = time;
            // Передаем событие активному режиму
            if (activeMode && activeMode.handleInteraction) activeMode.handleInteraction(e);
        }

        function onInteractionEnd(e) {
            if (activeMode && activeMode.handleInteraction) activeMode.handleInteraction(e);
        }

        function handleTouchStart(e) {
            touchStartX = e.touches[0].clientX;
            touchStartY = e.touches[0].clientY;
            isSwiping = false;
            onInteractionStart(e); 
        }

        function handleTouchMove(e) {
            if (!touchStartX || !touchStartY) return;
            
            const currentX = e.touches[0].clientX;
            const currentY = e.touches[0].clientY;
            const diffX = touchStartX - currentX;
            const diffY = touchStartY - currentY;
            
            if (!isSwiping) { 
                 if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > 10) {
                    isSwiping = 'horizontal';
                 } else if (Math.abs(diffY) > Math.abs(diffX) && Math.abs(diffY) > 10) {
                    isSwiping = 'vertical';
                 }
            }
            
            if (isSwiping === 'horizontal' || isSwiping === 'vertical') {
                e.preventDefault(); // Запрещаем скролл страницы только если это свайп
            }

             if (isSwiping === 'vertical') {
                 if (diffY > 50 && !isSettingsOpen) { // Свайп вверх
                    settingsOverlay.classList.add('open');
                    isSettingsOpen = true;
                    populateSettings(activeModeName); 
                 } else if (diffY < -50 && isSettingsOpen) { // Свайп вниз
                    settingsOverlay.classList.remove('open');
                    isSettingsOpen = false;
                 }
            } else if (!isSwiping) {
                // Если еще не определен свайп, вызываем onInteractionMove
                onInteractionMove(e);
            }
        }

        function handleTouchEnd(e) {
             if (isSwiping === 'horizontal') {
                const diffX = touchStartX - (e.changedTouches[0].clientX);
                if (Math.abs(diffX) > 50) { 
                    if (diffX > 0) switchMode((currentModeIndex + 1) % modeOrder.length, 1);
                    else switchMode((currentModeIndex - 1 + modeOrder.length) % modeOrder.length, -1);
                }
             } else if (isSwiping !== 'vertical') { 
                onInteractionEnd(e);
             }
             
             touchStartX = 0; touchStartY = 0; isSwiping = false;
        }
        
        // --- Инициализация ---
        function init() {
            // WebGL База
            webglRenderer = new THREE.WebGLRenderer({ canvas: webglCanvas, antialias: true, alpha: true });
            webglRenderer.setSize(window.innerWidth, window.innerHeight);
            webglRenderer.setPixelRatio(window.devicePixelRatio);
            webglRenderer.setClearColor(0x05050A, 1); 
            webglScene = new THREE.Scene();
            webglClock = new THREE.Clock();
            raycaster = new THREE.Raycaster();
            
            // Инициализация UI
            updateModeIndicator();

            // Запускаем первый режим
            switchMode(0);
            
            // Запускаем главный цикл анимации
            function globalAnimate() {
                 globalRAFID = requestAnimationFrame(globalAnimate);
                 const time = webglClock.getElapsedTime();
                 
                 const isWebGLActive = webglCanvas.style.display !== 'none';
                 if (isWebGLActive) {
                    // webglRenderer.clear(); // Очистка не нужна, если рендерим сцену целиком
                     if (activeMode && activeMode.update) {
                         activeMode.update(time);
                     }
                 }
                 
                 lastMousePos.vel *= 0.9; 
                 if (lastMousePos.vel < 0.01) lastMousePos.vel = 0.0;
            }
             globalAnimate(); 

            // Добавляем слушатели
            document.addEventListener('touchstart', handleTouchStart, { passive: false });
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd);
            document.addEventListener('mousedown', onInteractionStart);
            document.addEventListener('mousemove', onInteractionMove);
            document.addEventListener('mouseup', onInteractionEnd);

             // Закрытие настроек по клику вне
             document.addEventListener('click', (e) => {
                 if (isSettingsOpen && !settingsOverlay.contains(e.target)) {
                     settingsOverlay.classList.remove('open');
                     isSettingsOpen = false;
                 }
             });

             // Применение Настроек
             settingsContent.addEventListener('input', (e) => {
                 if (e.target.type !== 'range' || !activeMode || !activeMode.settings) return;
                 const setting = e.target.dataset.setting;
                 const value = parseFloat(e.target.value);
                 activeMode.settings[setting] = value;
                 let label = e.target.previousElementSibling;
                 if (label) {
                    let decimals = (setting === 'damping' || setting === 'rippleDecay') ? 2 : 1; // Исправлено
                    if (setting === 'count' || setting === 'fontSize' || setting === 'blur' || setting === 'frequency') decimals = 0; // Исправлено
                     label.textContent = `${setting} (${value.toFixed(decimals)})`;
                 }
                 if (activeMode.applySettings) activeMode.applySettings();
             });
             
             // --- Управление с клавиатуры ---
             document.addEventListener('keydown', (e) => {
                 if (e.key === 'ArrowLeft') {
                     switchMode((currentModeIndex - 1 + modeOrder.length) % modeOrder.length, -1);
                 } else if (e.key === 'ArrowRight') {
                     switchMode((currentModeIndex + 1) % modeOrder.length, 1);
                 } else if (e.key === 'ArrowUp') {
                     settingsOverlay.classList.add('open');
                     isSettingsOpen = true;
                     populateSettings(activeModeName);
                 } else if (e.key === 'ArrowDown') {
                      settingsOverlay.classList.remove('open');
                     isSettingsOpen = false;
                 }
             });
        }

        // Запускаем init только после загрузки DOM
        document.addEventListener('DOMContentLoaded', init);
        
        // Ресайз
        window.addEventListener('resize', () => {
            const w = window.innerWidth;
            const h = window.innerHeight;
            if (webglRenderer) webglRenderer.setSize(w, h); // Обновляем рендерер

            // Сообщаем активному режиму об изменении размера
            if (activeMode && activeMode.resize) {
                activeMode.resize(w, h);
            }
             // Ресайз для Matrix
             if (modeInstances['matrix'] && modeInstances['matrix'].resize) {
                 modeInstances['matrix'].resize();
             }
        });

    </script>
</body>
</html>

