<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FLOW v4 (Stage 1)</title>
    <!-- TailwindCSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js (Audio) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.min.js"></script>
    <!-- Three.js (WebGL) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #05050A;
            color: white;
            font-family: 'Inter', -apple-system, sans-serif;
            -webkit-tap-highlight-color: transparent;
        }
        
        /* Холст для всего WebGL */
        #webgl-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        /* UI Стили (Панель инструментов и Настройки) */
        #control-toolbar {
            position: fixed;
            right: 0;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 16px 12px;
            background: rgba(20, 20, 30, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-right: none;
            border-radius: 16px 0 0 16px;
            z-index: 100;
        }
        .control-btn {
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.05);
            color: rgba(255, 255, 255, 0.5);
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .control-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: white;
        }
        .control-btn.active {
            background: #a78bfa; /* Violet */
            color: white;
        }
        .control-btn svg { width: 24px; height: 24px; }
        
        #settings-panel {
            position: fixed;
            right: -300px; /* Спрятано */
            top: 0;
            width: 300px;
            height: 100%;
            background: rgba(15, 15, 25, 0.8);
            backdrop-filter: blur(15px);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 99;
            transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            padding: 20px;
            box-sizing: border-box;
            color: #eee;
        }
        #settings-panel.open {
            transform: translateX(-300px);
        }
        #settings-panel h3 {
            font-size: 1.25rem;
            font-weight: 600;
            margin-bottom: 24px;
        }
        .setting { margin-bottom: 20px; }
        .setting label {
            display: block;
            font-size: 0.8rem;
            color: #aaa;
            margin-bottom: 8px;
        }
        /* Кастомный слайдер */
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 18px;
            height: 18px;
            background: #a78bfa;
            border-radius: 50%;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            width: 18px;
            height: 18px;
            background: #a78bfa;
            border-radius: 50%;
            cursor: pointer;
        }
        .setting button {
            width: 100%;
            padding: 10px;
            background: #a78bfa;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    
    <!-- Единый холст для всех WebGL-приложений -->
    <canvas id="webgl-canvas"></canvas>

    <!-- UI Панель Инструментов (Новые иконки) -->
    <div id="control-toolbar">
        <!-- 1. Reflect 2.0 (Жидкий Шейдер) -->
        <button class="control-btn active" data-mode="reflect">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M19.428 15.428a2.143 2.143 0 00-3.03 0l-8.204 8.204a2.143 2.143 0 01-3.03-3.03l8.204-8.204a2.143 2.143 0 000-3.03L4.572 4.572a2.143 2.143 0 013.03-3.03l8.204 8.204a2.143 2.143 0 003.03 0l-1.39-1.39a2.143 2.143 0 013.03 3.03l-1.39 1.39z"></path></svg>
        </button>
        <!-- 2. Toroid (Тороидальный Поток) -->
        <button class="control-btn" data-mode="toroid">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
        </button>
        <!-- 3. Zen Garden (Сад Камней) -->
        <button class="control-btn" data-mode="zen">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M3 5h18M3 12h18M3 19h18"></path></svg>
        </button>
        <!-- 4. Cymatics 2.0 (Генератор Гармоник) -->
        <button class="control-btn" data-mode="cymatics">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M4 8l4 4 4-4 4 4 4-4M4 16l4 4 4-4 4 4 4-4"></path></svg>
        </button>
        <!-- 5. Weaver (Ткач) -->
        <button class="control-btn" data-mode="weaver">
            <svg fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.52 4.675a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.52 4.675c.3.921-.755 1.688-1.54 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.784.57-1.838-.197-1.54-1.118l1.52-4.675a1 1 0 00-.363-1.118L2.05 10.1c-.783-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.52-4.675z"></path></svg>
        </button>
    </div>

    <!-- Панель Настроек -->
    <div id="settings-panel">
        <h3 id="settings-title">Настройки</h3>
        <div id="settings-content">
            <!-- Содержимое будет вставлено JS -->
        </div>
    </div>
    
    <!-- 
    =====================================================================
    ШЕЙДЕРЫ (GLSL)
    =====================================================================
    -->
    
    <!-- 1. Reflect 2.0 (Fluid Shader) -->
    <script id="reflect-fs" type="x-shader/x-fragment">
        uniform vec2 u_resolution;
        uniform float u_time;
        uniform vec2 u_mouse_pos; // Позиция мыши
        uniform float u_mouse_vel; // Скорость (энергия)
        uniform float u_complexity; // Настройка сложности
        uniform float u_speed; // Настройка скорости
        
        // 2D Simplex Noise (Нужен для FBM)
        vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
        vec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }
        float snoise(vec2 v) {
            const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);
            vec2 i = floor(v + dot(v, C.yy));
            vec2 x0 = v - i + dot(i, C.xx);
            vec2 i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);
            vec2 x1 = x0.xy + C.xx - i1;
            vec2 x2 = x0.xy + C.zz;
            i = mod289(i);
            vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));
            vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x1, x1), dot(x2, x2)), 0.0);
            m = m * m; m = m * m;
            vec3 x = 2.0 * fract(p * C.www) - 1.0;
            vec3 h = abs(x) - 0.5;
            vec3 ox = floor(x + 0.5);
            vec3 a0 = x - ox;
            m *= (1.79284291400159 - 0.85373472095314 * (a0 * a0 + h * h));
            vec3 g;
            g.x = a0.x * x0.x + h.x * x0.y;
            g.yz = a0.yz * vec2(x1.x, x2.x) + h.yz * vec2(x1.y, x2.y);
            return 130.0 * dot(m, g);
        }

        // FBM (Fractal Brownian Motion) - Слои шума
        float fbm(vec2 v, float complexity) {
            float total = 0.0;
            float amplitude = 0.5;
            float frequency = 1.0;
            for (int i = 0; i < 7; i++) {
                if (float(i) > complexity) break; 
                total += snoise(v * frequency) * amplitude;
                frequency *= 2.0;
                amplitude *= 0.5;
            }
            return total;
        }

        void main() {
            vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;
            vec2 mouse = (u_mouse_pos - 0.5 * u_resolution.xy) / u_resolution.y;
            
            float time = u_time * u_speed * 0.1;
            float complexity = u_complexity; // 3.0 to 7.0

            // 1. Создаем вихрь (vortex) от мыши
            float dist_to_mouse = length(uv - mouse);
            float vortex = (u_mouse_vel * 0.1) / (dist_to_mouse + 0.1); // Сила вихря
            float angle = atan(uv.y - mouse.y, uv.x - mouse.x);
            
            // Искажаем UV-координаты этим вихрем
            vec2 vortex_uv = uv + vec2(cos(angle), sin(angle)) * vortex;

            // 2. Создаем "поле течения" (Flow Field)
            vec2 flow_vec = vec2(vortex_uv.x * 0.5 + time, vortex_uv.y * 0.5);
            float flow = fbm(flow_vec, complexity) * 0.5;
            vec2 distorted_uv = vortex_uv + vec2(flow * 0.3);
            
            // 3. Создаем "чернила" (Ink)
            vec2 ink_vec = vec2(distorted_uv * 1.0 + time * 0.5);
            float ink = fbm(ink_vec, complexity); // от -1 до 1
            
            // 4. Окрашивание
            float value = smoothstep(-0.2, 0.2, ink); // Более контрастно
            
            // Цвета (gothic/opium)
            vec3 colorA = vec3(0.01, 0.0, 0.02); // Фон (Багрово-черный)
            vec3 colorB = vec3(0.1, 0.0, 0.3); // Фиолетовый
            vec3 colorC = vec3(0.8, 0.1, 0.2); // Красный
            vec3 colorD = vec3(1.0, 0.5, 0.3); // Ярко-оранжевый

            vec3 color = mix(colorA, colorB, smoothstep(0.0, 0.2, value));
            color = mix(color, colorC, smoothstep(0.2, 0.6, value));
            color = mix(color, colorD, smoothstep(0.6, 0.8, value));
            
            gl_FragColor = vec4(color, 1.0);
        }
    </script>
    
    <!-- 2. Cymatics 2.0 (Harmonic Shader) -->
    <script id="cymatics-fs" type="x-shader/x-fragment">
        uniform float u_time;
        uniform vec3 u_color;
        uniform float u_frequencies[5]; // Массив из 5 активных частот
        uniform float u_amplitudes[5]; // Массив амплитуд (громкости)
        
        varying vec2 vUv; // Получаем из Vertex Shader

        void main() {
            float total_wave = 0.0;
            float total_amplitude = 0.0;

            for(int i=0; i < 5; i++) {
                if (u_amplitudes[i] > 0.0) {
                    float freq = u_frequencies[i] * 0.01; // Масштабируем
                    float amp = u_amplitudes[i];
                    
                    // Простая симуляция стоячей волны
                    total_wave += sin(vUv.x * freq * 10.0 + u_time) *
                                  cos(vUv.y * freq * 10.0 + u_time) * amp;
                    total_amplitude += amp;
                }
            }

            if (total_amplitude > 0.0) {
                total_wave /= total_amplitude;
            }

            float value = smoothstep(-0.5, 0.5, total_wave);
            
            gl_FragColor = vec4(u_color * value, 1.0);
        }
    </script>
    <script id="cymatics-vs" type="x-shader/x-vertex">
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    </script>
    
    <!-- 
    =====================================================================
    ОСНОВНОЙ JAVASCRIPT
    =====================================================================
    -->
    <script>
        // --- Глобальные переменные ---
        let activeMode = null;
        let interactionEnergy = 0.0;
        let lastMousePos = { x: 0, y: 0, vel: 0.0 };
        let audioState = { isReady: false, polySynth: null, analyser: null };

        let renderer, scene, camera, clock, raycaster, mouse;
        
        const settingsPanel = document.getElementById('settings-panel');
        const settingsTitle = document.getElementById('settings-title');
        const settingsContent = document.getElementById('settings-content');
        const toolbar = document.getElementById('control-toolbar');

        // --- Настройки по умолчанию ---
        const settings = {
            reflect: { speed: 1.0, complexity: 5.0 },
            toroid: { speed: 0.5, radius: 15.0 },
            zen: { brushSize: 10.0 },
            cymatics: { scale: 'Pentatonic', baseNote: 'C3' },
            weaver: { gravity: 1.0, damping: 0.95 }
        };
        
        // --- Аудио Контекст ---
        async function initAudio() {
            if (audioState.isReady) return;
            try {
                if (typeof window.Tone === 'undefined') {
                    console.error("Tone.js не загружен."); return;
                }
                
                await window.Tone.start();
                const reverb = new window.Tone.Reverb({ decay: 10, wet: 0.5 }).toDestination();
                await reverb.generate();
                
                // Полифонический синтезатор для "Cymatics"
                const polySynth = new window.Tone.PolySynth(window.Tone.Synth, {
                    oscillator: { type: 'sine' },
                    envelope: { attack: 0.5, decay: 0.1, sustain: 0.8, release: 1.0 }
                }).connect(reverb);
                
                // Анализатор для обратной связи в шейдер
                const analyser = new window.Tone.Analyser('fft', 32); // 32 полосы
                polySynth.connect(analyser);

                audioState = { isReady: true, polySynth, analyser };
                console.log("Audio Engine Ready.");
            } catch (e) { 
                console.error("Audio failed to start:", e); 
            }
        }
        
        // --- Базовый Класс для Режимов ---
        class Mode {
            constructor() {
                this.scene = new THREE.Scene();
                this.settings = settings[this.constructor.name.toLowerCase().replace('mode', '')];
            }
            init(renderer, mainScene, mainCamera) {}
            show() { scene.add(this.scene); }
            hide() { scene.remove(this.scene); }
            update(time, energy) {}
            dispose() {
                // Очистка геометрии, материалов и т.д.
                this.scene.traverse(object => {
                    if (object.geometry) object.geometry.dispose();
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(material => material.dispose());
                        } else {
                            object.material.dispose();
                        }
                    }
                });
                this.hide();
            }
            populateSettings(container) { container.innerHTML = ''; }
            handleInteraction(event) {}
        }
        
        // --- 1. Reflect 2.0 (Жидкий Шейдер) ---
        class ReflectMode extends Mode {
            init() {
                this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
                const geometry = new THREE.PlaneGeometry(2, 2);
                this.material = new THREE.ShaderMaterial({
                    fragmentShader: document.getElementById('reflect-fs').textContent,
                    uniforms: {
                        u_time: { value: 0.0 },
                        u_resolution: { value: new THREE.Vector2(window.innerWidth, window.innerHeight) },
                        u_mouse_pos: { value: new THREE.Vector2(window.innerWidth / 2, window.innerHeight / 2) },
                        u_mouse_vel: { value: 0.0 },
                        u_complexity: { value: this.settings.complexity },
                        u_speed: { value: this.settings.speed }
                    }
                });
                const quad = new THREE.Mesh(geometry, this.material);
                this.scene.add(quad);
            }
            
            update(time) {
                this.material.uniforms.u_time.value = time * 0.1;
                this.material.uniforms.u_mouse_vel.value = lastMousePos.vel * 0.1;
                this.material.uniforms.u_mouse_pos.value.set(lastMousePos.x, window.innerHeight - lastMousePos.y); // Y инвертирован в GLSL
                renderer.render(this.scene, this.camera);
            }
            
            populateSettings(container) {
                container.innerHTML = `
                    <div class="setting">
                        <label for="speed-slider">Скорость (${this.settings.speed.toFixed(1)})</label>
                        <input type="range" id="speed-slider" data-setting="speed" min="0.1" max="5" step="0.1" value="${this.settings.speed}">
                    </div>
                    <div class="setting">
                        <label for="complexity-slider">Сложность (${this.settings.complexity.toFixed(0)})</label>
                        <input type="range" id="complexity-slider" data-setting="complexity" min="3" max="7" step="1" value="${this.settings.complexity}">
                    </div>
                `;
                // Слушатели
                container.querySelector('#speed-slider').addEventListener('input', e => {
                    this.settings.speed = parseFloat(e.target.value);
                    this.material.uniforms.u_speed.value = this.settings.speed;
                    e.target.previousElementSibling.textContent = `Скорость (${this.settings.speed.toFixed(1)})`;
                });
                container.querySelector('#complexity-slider').addEventListener('input', e => {
                    this.settings.complexity = parseFloat(e.target.value);
                    this.material.uniforms.u_complexity.value = this.settings.complexity;
                    e.target.previousElementSibling.textContent = `Сложность (${this.settings.complexity.toFixed(0)})`;
                });
            }
            
            handleInteraction(event) {
                // Эта логика (обновление lastMousePos) уже в глобальном обработчике
            }
        }

        // --- 2. Toroid (Тороидальный Поток) ---
        class ToroidMode extends Mode {
            init() {
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.z = 30;
                
                const count = 5000;
                const R = this.settings.radius; // Большой радиус
                const r = 5.0; // Малый радиус
                
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(count * 3);
                const data = []; // u, v, speed
                
                for (let i = 0; i < count; i++) {
                    const u = Math.random() * Math.PI * 2;
                    const v = Math.random() * Math.PI * 2;
                    data.push({ u, v, speed: 0.1 + Math.random() * 0.4 });
                    
                    positions[i * 3] = (R + r * Math.cos(v)) * Math.cos(u);
                    positions[i * 3 + 1] = (R + r * Math.cos(v)) * Math.sin(u);
                    positions[i * 3 + 2] = r * Math.sin(v);
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.userData.data = data;
                geometry.userData.r = r; // Сохраняем для update
                
                const material = new THREE.PointsMaterial({ color: '#a78bfa', size: 0.1 });
                this.torusParticles = new THREE.Points(geometry, material);
                this.scene.add(this.torusParticles);
                
                // Для вращения мышью
                this.isDragging = false;
                this.previousMousePos = { x: 0, y: 0 };
            }
            
            update(time) {
                const R = this.settings.radius;
                const r = this.torusParticles.geometry.userData.r;
                const data = this.torusParticles.geometry.userData.data;
                const positions = this.torusParticles.geometry.attributes.position.array;
                const speed = this.settings.speed * 0.1;
                
                for(let i=0; i < data.length; i++) {
                    data[i].u += data[i].speed * speed; // Анимация по большому кругу
                    data[i].v += 0.01 * speed; // Анимация по малому
                    
                    const u = data[i].u;
                    const v = data[i].v;
                    
                    positions[i * 3] = (R + r * Math.cos(v)) * Math.cos(u);
                    positions[i * 3 + 1] = (R + r * Math.cos(v)) * Math.sin(u);
                    positions[i * 3 + 2] = r * Math.sin(v);
                }
                this.torusParticles.geometry.attributes.position.needsUpdate = true;
                
                renderer.render(this.scene, this.camera);
            }

            handleInteraction(event) {
                if (event.type === 'mousedown' || event.type === 'touchstart') {
                    this.isDragging = true;
                    this.previousMousePos.x = event.clientX || event.touches[0].clientX;
                    this.previousMousePos.y = event.clientY || event.touches[0].clientY;
                }
                if (event.type === 'mouseup' || event.type === 'touchend') {
                    this.isDragging = false;
                }
                if (event.type === 'mousemove' || event.type === 'touchmove') {
                    if (!this.isDragging) return;
                    
                    const clientX = event.clientX || event.touches[0].clientX;
                    const clientY = event.clientY || event.touches[0].clientY;
                    
                    const deltaX = clientX - this.previousMousePos.x;
                    const deltaY = clientY - this.previousMousePos.y;
                    
                    // Вращение
                    const rotX = deltaY * 0.01;
                    const rotY = deltaX * 0.01;
                    
                    // Вращаем вокруг осей X и Y
                    this.torusParticles.rotateOnWorldAxis(new THREE.Vector3(1, 0, 0), rotX);
                    this.torusParticles.rotateOnWorldAxis(new THREE.Vector3(0, 1, 0), rotY);
                    
                    this.previousMousePos.x = clientX;
                    this.previousMousePos.y = clientY;
                }
            }
        }
        
        // --- 3. Zen Garden (Сад Камней) ---
        class ZenMode extends Mode {
            init() {
                this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 50, 0); // Смотрим сверху вниз
                this.camera.lookAt(0, 0, 0);
                
                // 1. 2D-холст для рисования "следов"
                this.sandCanvas = document.createElement('canvas');
                this.sandCanvas.width = 1024;
                this.sandCanvas.height = 1024;
                this.sandCtx = this.sandCanvas.getContext('2d');
                
                // Заполняем "песком" (светло-бежевый)
                this.sandCtx.fillStyle = '#EAE6CA';
                this.sandCtx.fillRect(0, 0, 1024, 1024);
                
                // 2. 3D-плоскость
                this.sandTexture = new THREE.CanvasTexture(this.sandCanvas);
                const geometry = new THREE.PlaneGeometry(100, 100);
                const material = new THREE.MeshStandardMaterial({
                    map: this.sandTexture,
                    // Добавляем карту нормалей для рельефа "песка"
                    // normalMap: ... (нужна ссылка на текстуру)
                });
                this.sandPlane = new THREE.Mesh(geometry, material);
                this.sandPlane.rotation.x = -Math.PI / 2; // Кладем на пол
                this.scene.add(this.sandPlane);

                // Освещение
                const ambient = new THREE.AmbientLight(0xffffff, 0.7);
                this.scene.add(ambient);
                const sun = new THREE.DirectionalLight(0xffffff, 0.5);
                sun.position.set(20, 50, 20);
                this.scene.add(sun);

                this.isDrawing = false;
            }
            
            update() {
                renderer.render(this.scene, this.camera);
            }
            
            handleInteraction(event) {
                if (event.type === 'mousedown' || event.type === 'touchstart') {
                    this.isDrawing = true;
                    this.drawOnSand(event);
                }
                if (event.type === 'mouseup' || event.type === 'touchend') {
                    this.isDrawing = false;
                }
                if ((event.type === 'mousemove' || event.type === 'touchmove') && this.isDrawing) {
                    this.drawOnSand(event);
                }
            }

            drawOnSand(event) {
                const clientX = event.clientX || event.touches[0].clientX;
                const clientY = event.clientY || event.touches[0].clientY;
                
                mouse.x = (clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(clientY / window.innerHeight) * 2 + 1;
                
                raycaster.setFromCamera(mouse, this.camera);
                const intersects = raycaster.intersectObject(this.sandPlane);
                
                if (intersects.length > 0) {
                    const uv = intersects[0].uv; // Координаты (0.0 to 1.0)
                    const x = uv.x * this.sandCanvas.width;
                    const y = (1.0 - uv.y) * this.sandCanvas.height; // Y инвертирован
                    
                    // Рисуем "след" на 2D-холсте
                    this.sandCtx.fillStyle = 'rgba(0, 0, 0, 0.05)'; // Темный след
                    this.sandCtx.beginPath();
                    this.sandCtx.arc(x, y, this.settings.brushSize, 0, Math.PI * 2);
                    this.sandCtx.fill();
                    
                    // Обновляем 3D-текстуру
                    this.sandTexture.needsUpdate = true;
                }
            }

            populateSettings(container) {
                container.innerHTML = `
                    <div class="setting">
                        <label for="brush-slider">Размер кисти (${this.settings.brushSize.toFixed(0)})</label>
                        <input type="range" id="brush-slider" data-setting="brushSize" min="5" max="50" step="1" value="${this.settings.brushSize}">
                    </div>
                    <div class="setting">
                        <button id="clear-sand-btn">Очистить песок</button>
                    </div>
                `;
                container.querySelector('#brush-slider').addEventListener('input', e => {
                    this.settings.brushSize = parseFloat(e.target.value);
                    e.target.previousElementSibling.textContent = `Размер кисти (${this.settings.brushSize.toFixed(0)})`;
                });
                container.querySelector('#clear-sand-btn').addEventListener('click', () => {
                    this.sandCtx.fillStyle = '#EAE6CA';
                    this.sandCtx.fillRect(0, 0, 1024, 1024);
                    this.sandTexture.needsUpdate = true;
                });
            }
        }
        
        // --- 4. Cymatics 2.0 (Генератор Гармоник) ---
        class CymaticsMode extends Mode {
            init() {
                this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
                const geometry = new THREE.PlaneGeometry(2, 2);
                this.material = new THREE.ShaderMaterial({
                    vertexShader: document.getElementById('cymatics-vs').textContent,
                    fragmentShader: document.getElementById('cymatics-fs').textContent,
                    uniforms: {
                        u_time: { value: 0.0 },
                        u_color: { value: new THREE.Color('#a78bfa') },
                        u_frequencies: { value: [0.0, 0.0, 0.0, 0.0, 0.0] },
                        u_amplitudes: { value: [0.0, 0.0, 0.0, 0.0, 0.0] }
                    }
                });
                const quad = new THREE.Mesh(geometry, this.material);
                this.scene.add(quad);
                
                // Музыкальная логика
                this.scale = ['C3', 'D3', 'E3', 'G3', 'A3', 'C4', 'D4', 'E4', 'G4', 'A4'];
                this.activeNotes = {}; // { "C3": true }
            }
            
            update(time) {
                this.material.uniforms.u_time.value = time;
                
                if (audioState.isReady && audioState.analyser) {
                    const fft = audioState.analyser.getValue();
                    // Упрощенно передаем 5 значений в шейдер
                    const amps = [0.0, 0.0, 0.0, 0.0, 0.0];
                    const freqs = [0.0, 0.0, 0.0, 0.0, 0.0];
                    let notes = Object.keys(this.activeNotes);
                    
                    for(let i=0; i < 5; i++) {
                        if (i < fft.length && i < notes.length) {
                            // Нормализуем громкость (-100 to 0) -> (0 to 1)
                            amps[i] = Math.max(0, (fft[i] + 100) / 100); 
                            freqs[i] = window.Tone.Frequency(notes[i]).toFrequency();
                        }
                    }
                    
                    this.material.uniforms.u_amplitudes.value = amps;
                    this.material.uniforms.u_frequencies.value = freqs;
                }
                
                renderer.render(this.scene, this.camera);
            }
            
            handleInteraction(event) {
                if (!audioState.isReady) initAudio(); // Запускаем, если еще не
                
                const clientX = event.clientX || (event.touches ? event.touches[0].clientX : 0);
                const clientY = event.clientY || (event.touches ? event.touches[0].clientY : 0);
                
                // X -> Нота, Y -> Октава (упрощенно)
                const noteIndex = Math.floor((clientX / window.innerWidth) * this.scale.length);
                const note = this.scale[noteIndex];
                
                if (event.type === 'mousedown' || event.type === 'touchstart') {
                    if (note && !this.activeNotes[note]) {
                        audioState.polySynth.triggerAttack(note);
                        this.activeNotes[note] = true;
                    }
                }
                if (event.type === 'mouseup' || event.type === 'touchend') {
                    // Отпускаем *все* ноты для простоты
                    audioState.polySynth.releaseAll();
                    this.activeNotes = {};
                }
                if ((event.type === 'mousemove' || event.type === 'touchmove')) {
                    if (note && !this.activeNotes[note]) {
                        audioState.polySynth.releaseAll();
                        this.activeNotes = {};
                        audioState.polySynth.triggerAttack(note);
                        this.activeNotes[note] = true;
                    }
                }
            }
        }
        
        // --- 5. Weaver (Ткач) ---
        class WeaverMode extends Mode {
            init() {
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.z = 50;
                
                const count = 3000;
                const geometry = new THREE.BufferGeometry();
                const positions = new Float32Array(count * 3);
                const velocities = new Float32Array(count * 3);
                
                for (let i = 0; i < count; i++) {
                    positions[i * 3] = (Math.random() - 0.5) * 100;
                    positions[i * 3 + 1] = (Math.random() - 0.5) * 100;
                    positions[i * 3 + 2] = (Math.random() - 0.5) * 100;
                    velocities[i * 3] = 0;
                    velocities[i * 3 + 1] = 0;
                    velocities[i * 3 + 2] = 0;
                }
                
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.userData.velocities = velocities;
                
                const material = new THREE.PointsMaterial({ color: '#a78bfa', size: 0.1, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.7 });
                this.particles = new THREE.Points(geometry, material);
                this.scene.add(this.particles);

                this.gravityWell = new THREE.Vector3(0, 0, 0);
                this.isAttracting = false;
            }
            
            update() {
                const positions = this.particles.geometry.attributes.position.array;
                const velocities = this.particles.geometry.userData.velocities;
                const gravity = this.settings.gravity * 0.1;
                const damping = this.settings.damping;

                for (let i = 0; i < positions.length; i += 3) {
                    // 1. Притяжение (если активно)
                    if (this.isAttracting) {
                        const dx = this.gravityWell.x - positions[i];
                        const dy = this.gravityWell.y - positions[i + 1];
                        const dz = this.gravityWell.z - positions[i + 2];
                        const distSq = dx * dx + dy * dy + dz * dz;
                        
                        if (distSq > 1.0) {
                            const force = gravity / (distSq + 1.0); // +1 чтобы избежать деления на 0
                            velocities[i] += dx * force;
                            velocities[i + 1] += dy * force;
                            velocities[i + 2] += dz * force;
                        }
                    }
                    
                    // 2. Затухание
                    velocities[i] *= damping;
                    velocities[i + 1] *= damping;
                    velocities[i + 2] *= damping;
                    
                    // 3. Движение
                    positions[i] += velocities[i];
                    positions[i + 1] += velocities[i + 1];
                    positions[i + 2] += velocities[i + 2];
                }
                this.particles.geometry.attributes.position.needsUpdate = true;
                
                renderer.render(this.scene, this.camera);
            }
            
            handleInteraction(event) {
                const clientX = event.clientX || (event.touches ? event.touches[0].clientX : 0);
                const clientY = event.clientY || (event.touches ? event.touches[0].clientY : 0);
                
                // Обновляем позицию "колодца"
                mouse.x = (clientX / window.innerWidth) * 2 - 1;
                mouse.y = -(clientY / window.innerHeight) * 2 + 1;
                raycaster.setFromCamera(mouse, this.camera);
                
                // Проецируем на плоскость Z=0
                const plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
                raycaster.ray.intersectPlane(plane, this.gravityWell);

                if (event.type === 'mousedown' || event.type === 'touchstart') {
                    this.isAttracting = true;
                }
                if (event.type === 'mouseup' || event.type === 'touchend') {
                    this.isAttracting = false;
                }
            }
        }

        // --- Менеджер Режимов ---
        const modeManager = {
            modes: {
                reflect: ReflectMode,
                toroid: ToroidMode,
                zen: ZenMode,
                cymatics: CymaticsMode,
                weaver: WeaverMode
            },
            
            switchMode(newModeName) {
                if (activeMode) {
                    activeMode.dispose();
                }
                
                const ModeClass = this.modes[newModeName];
                if (!ModeClass) {
                    console.error(`Режим ${newModeName} не найден!`);
                    return;
                }
                
                activeMode = new ModeClass();
                activeMode.init();
                activeMode.show();
                
                // Обновляем UI
                toolbar.querySelector('.active')?.classList.remove('active');
                toolbar.querySelector(`[data-mode="${newModeName}"]`).classList.add('active');
                
                settingsTitle.textContent = `Настройки: ${newModeName}`;
                activeMode.populateSettings(settingsContent);
                settingsPanel.classList.add('open');
            }
        };

        // --- Главный Цикл Анимации ---
        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            
            // Обновляем энергию
            interactionEnergy = lastMousePos.vel * 0.01;
            lastMousePos.vel *= 0.95; // Затухание
            
            if (activeMode && activeMode.update) {
                activeMode.update(time, interactionEnergy);
            }
        }

        // --- Глобальные Обработчики ---
        function onWindowResize() {
            const w = window.innerWidth;
            const h = window.innerHeight;
            
            renderer.setSize(w, h);
            
            if (activeMode && activeMode.camera) {
                activeMode.camera.aspect = w / h;
                activeMode.camera.updateProjectionMatrix();
            }
            if (activeMode && activeMode.material && activeMode.material.uniforms.u_resolution) {
                activeMode.material.uniforms.u_resolution.value.set(w, h);
            }
        }
        
        function onInteractionStart(e) {
            initAudio(); // Запуск аудио по первому клику
            const x = e.clientX || e.touches[0].clientX;
            const y = e.clientY || e.touches[0].clientY;
            lastMousePos.x = x;
            lastMousePos.y = y;
            if (activeMode && activeMode.handleInteraction) activeMode.handleInteraction(e);
        }
        
        function onInteractionMove(e) {
            const x = e.clientX || e.touches[0].clientX;
            const y = e.clientY || e.touches[0].clientY;
            const dx = x - lastMousePos.x;
            const dy = y - lastMousePos.y;
            lastMousePos.vel = Math.sqrt(dx * dx + dy * dy);
            lastMousePos.x = x;
            lastMousePos.y = y;
            if (activeMode && activeMode.handleInteraction) activeMode.handleInteraction(e);
        }
        
        function onInteractionEnd(e) {
            lastMousePos.vel = 0;
            if (activeMode && activeMode.handleInteraction) activeMode.handleInteraction(e);
        }

        // --- Инициализация ---
        function init() {
            // WebGL
            const canvas = document.getElementById('webgl-canvas');
            renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            scene = new THREE.Scene();
            clock = new THREE.Clock();
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Слушатели событий
            window.addEventListener('resize', onWindowResize);
            document.addEventListener('mousedown', onInteractionStart);
            document.addEventListener('mousemove', onInteractionMove);
            document.addEventListener('mouseup', onInteractionEnd);
            document.addEventListener('touchstart', onInteractionStart, { passive: false });
            document.addEventListener('touchmove', onInteractionMove, { passive: false });
            document.addEventListener('touchend', onInteractionEnd);
            
            // UI
            toolbar.addEventListener('click', (e) => {
                const btn = e.target.closest('.control-btn');
                if (!btn) return;
                modeManager.switchMode(btn.dataset.mode);
            });
            
            // Закрытие панели настроек
            document.body.addEventListener('click', (e) => {
                if (settingsPanel.classList.contains('open') && 
                    !settingsPanel.contains(e.target) && 
                    !toolbar.contains(e.target)) {
                    settingsPanel.classList.remove('open');
                }
            });

            // Запускаем первый режим
            modeManager.switchMode('reflect');
            
            // Запускаем главный цикл
            animate();
        }

        init();
    </script>
</body>
</html>
